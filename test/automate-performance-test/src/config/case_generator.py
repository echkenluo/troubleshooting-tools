#!/usr/bin/env python3
"""Test case generator and accessor.

Provides TestCase dataclass and filtering utilities for generated test cases.
Main case generation is handled by ConfigBootstrap.
"""

import json
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

logger = logging.getLogger(__name__)


@dataclass
class TestCase:
    """Generated test case for execution.

    Compatible with testcase_loader.py format.
    """
    id: int
    name: str
    command: str
    script: str
    category: str
    environment: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    duration: int = 10

    def to_dict(self) -> Dict:
        """Convert to dictionary format."""
        return {
            'id': self.id,
            'name': self.name,
            'command': self.command,
            'script': self.script,
            'category': self.category,
            'environment': self.environment,
            'parameters': self.parameters,
            'duration': self.duration
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'TestCase':
        """Create TestCase from dictionary."""
        return cls(
            id=data.get('id', 0),
            name=data.get('name', ''),
            command=data.get('command', ''),
            script=data.get('script', ''),
            category=data.get('category', ''),
            environment=data.get('environment', 'host'),
            parameters=data.get('parameters', {}),
            duration=data.get('duration', 10)
        )


class TestCaseGenerator:
    """Test case accessor with filtering capabilities.

    Works with test cases generated by ConfigBootstrap.
    """

    def __init__(self, test_cases: List[Dict] = None):
        """Initialize test case generator.

        Args:
            test_cases: List of test case dictionaries
        """
        self.cases: List[TestCase] = []
        if test_cases:
            self.load_cases(test_cases)

    def load_cases(self, test_cases: List[Dict]):
        """Load test cases from list of dictionaries.

        Args:
            test_cases: List of test case dictionaries
        """
        self.cases = [TestCase.from_dict(tc) for tc in test_cases]
        logger.info(f"Loaded {len(self.cases)} test cases")

    def load_from_file(self, filepath: str):
        """Load test cases from JSON file.

        Args:
            filepath: Path to test cases JSON file
        """
        with open(filepath, 'r') as f:
            data = json.load(f)

        if 'test_cases' in data:
            test_cases = data['test_cases']
        elif isinstance(data, list):
            test_cases = data
        else:
            raise ValueError(f"Invalid test cases format in {filepath}")

        self.load_cases(test_cases)

    def get_all(self) -> List[TestCase]:
        """Get all test cases."""
        return self.cases

    def get_by_id(self, case_id: int) -> Optional[TestCase]:
        """Get test case by ID."""
        for case in self.cases:
            if case.id == case_id:
                return case
        return None

    def filter(self,
               environment: str = None,
               category: str = None,
               protocol: str = None,
               direction: str = None,
               script: str = None) -> List[TestCase]:
        """Filter test cases by criteria.

        Args:
            environment: Filter by environment (host/vm)
            category: Filter by category (exact match or prefix)
            protocol: Filter by protocol parameter
            direction: Filter by direction parameter
            script: Filter by script name (substring match)

        Returns:
            Filtered list of test cases
        """
        result = self.cases

        if environment:
            result = [c for c in result if c.environment == environment]

        if category:
            result = [c for c in result
                     if c.category == category or c.category.startswith(category)]

        if protocol:
            result = [c for c in result
                     if c.parameters.get('protocol') == protocol]

        if direction:
            result = [c for c in result
                     if c.parameters.get('direction') == direction]

        if script:
            result = [c for c in result if script in c.script]

        return result

    def get_by_environment(self, environment: str) -> List[TestCase]:
        """Get test cases for environment."""
        return self.filter(environment=environment)

    def get_by_category(self, category: str) -> List[TestCase]:
        """Get test cases for category."""
        return self.filter(category=category)

    def get_categories(self) -> List[str]:
        """Get list of all categories."""
        return sorted(set(c.category for c in self.cases))

    def get_environments(self) -> List[str]:
        """Get list of all environments."""
        return sorted(set(c.environment for c in self.cases))

    def get_scripts(self) -> List[str]:
        """Get list of all unique scripts."""
        return sorted(set(c.script for c in self.cases))

    def count(self) -> int:
        """Get total number of test cases."""
        return len(self.cases)

    def summary(self) -> Dict:
        """Get summary statistics."""
        by_env = {}
        by_cat = {}

        for case in self.cases:
            by_env[case.environment] = by_env.get(case.environment, 0) + 1
            by_cat[case.category] = by_cat.get(case.category, 0) + 1

        return {
            'total': len(self.cases),
            'by_environment': by_env,
            'by_category': by_cat
        }

    def to_ebpf_config_format(self) -> Dict:
        """Convert to ebpf-tools-config.yaml format for backward compatibility.

        Returns:
            Dictionary in ebpf_tools format
        """
        ebpf_tools = {}

        for case in self.cases:
            tool_id = case.script.replace('.py', '').replace('.bt', '').replace('-', '_')

            if tool_id not in ebpf_tools:
                ebpf_tools[tool_id] = {
                    'id': tool_id,
                    'name': case.script,
                    'testcase_source': {
                        'type': 'generated',
                        'case_ids': []
                    },
                    'test_associations': {
                        'applicable_environments': set(),
                        'performance_test_types': ['throughput', 'latency', 'pps']
                    },
                    'resource_monitoring': {
                        'cpu': True,
                        'memory': True,
                        'log_size': True
                    }
                }

            ebpf_tools[tool_id]['testcase_source']['case_ids'].append(case.id)
            ebpf_tools[tool_id]['test_associations']['applicable_environments'].add(case.environment)

        # Convert sets to lists
        for tool in ebpf_tools.values():
            tool['test_associations']['applicable_environments'] = \
                list(tool['test_associations']['applicable_environments'])

        return {'ebpf_tools': ebpf_tools}

    def get_case_ids_by_tool(self, tool_name: str) -> List[int]:
        """Get case IDs for a specific tool.

        Args:
            tool_name: Tool/script name (with or without .py)

        Returns:
            List of case IDs
        """
        if not tool_name.endswith('.py'):
            tool_name = f"{tool_name}.py"

        return [c.id for c in self.cases if c.script == tool_name]

    def export_to_file(self, filepath: str):
        """Export test cases to JSON file.

        Args:
            filepath: Output file path
        """
        data = {
            'metadata': {
                'total_cases': len(self.cases)
            },
            'test_cases': [c.to_dict() for c in self.cases]
        }

        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        logger.info(f"Exported {len(self.cases)} test cases to {filepath}")
