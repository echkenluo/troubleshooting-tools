# 第5章 常见问题与输出解读

---

## 5.1 工具运行问题

### Q1: 工具无输出

**可能原因**：

| 原因         | 排查方法                    | 解决方案           |
| ------------ | --------------------------- | ------------------ |
| 过滤条件过严 | 检查 IP/接口是否正确        | 放宽过滤条件先验证 |
| 没有匹配流量 | 用 tcpdump 确认流量存在     | 确保有测试流量     |
| 接口名错误   | `ip link show` 确认接口名 | 使用正确接口名     |
| 权限不足     | 是否使用 sudo               | 必须使用 root 权限 |

**排查步骤**：

```bash
# 步骤1：确认接口存在
ip link show | grep <接口名>

# 步骤2：确认接口有 ifindex
cat /sys/class/net/<接口名>/ifindex

# 步骤3：确认有匹配流量
sudo tcpdump -i <接口名> host <src-ip> and host <dst-ip> -c 10

# 步骤4：放宽过滤条件测试
sudo python icmp_path_tracer.py \
    --src-ip <src-ip> --dst-ip <dst-ip> \
    --rx-iface <接口1> --tx-iface <接口2>
```

### Q2: 提示 BPF 编译错误

**常见错误**：

```
error: use of undeclared identifier 'xxx'
```

**可能原因**：

- 内核版本不兼容
- BCC 版本过旧

**解决方案**：

```bash
# 检查内核版本
uname -r

# 检查 BCC 版本
python -c "import bcc; print(bcc.__version__)"

# 联系开发团队获取兼容版本
```

### Q3: 提示找不到 kprobe 点

**错误示例**：

```
cannot attach kprobe, probe entry may not exist
```

**可能原因**：

- 内核函数被内联优化
- 内核配置不支持该 kprobe

**解决方案**：

```bash
# 检查 kprobe 点是否存在
cat /sys/kernel/debug/tracing/available_filter_functions | grep <函数名>

# 联系开发团队适配
```

### Q4: 系统负载升高

**症状**：运行工具后 CPU 使用率明显上升

**可能原因**：

- 使用了 Details 工具未加过滤，事件速率过高
- 过滤条件不够严格，通过过滤的事件量大

**解决方案**：

```bash
# 立即停止工具
Ctrl+C

# 检查过滤条件
# 确保指定了 --src-ip 和 --dst-ip

# 评估过滤后的事件速率
timeout 10 tcpdump -i <接口> host <ip1> and host <ip2> -c 1000 2>&1 | tail -1

# 降低事件速率的方法：
# 1. 添加端口过滤（--src-port / --dst-port）
# 2. 使用延迟阈值过滤（--latency-ms），仅输出高延迟事件
# 3. 改用 Summary 工具（内核态聚合，开销低）
# 4. TCP/UDP path_tracer 使用 --stats-mode 替代 --verbose
```

---

## 5.2 输出解读指南

### 5.2.1 时间单位

| 单位   | 含义 | 典型范围         |
| ------ | ---- | ---------------- |
| `ns` | 纳秒 | BPF 内部时间戳   |
| `us` | 微秒 | 阶段延迟输出     |
| `ms` | 毫秒 | 总 RTT、超时阈值 |

**换算**：1ms = 1000us = 1000000ns

### 5.2.2 延迟值正常范围参考

| 场景         | 正常范围  | 告警阈值 |
| ------------ | --------- | -------- |
| 同机 VM 间   | 50-200us  | > 500us  |
| 同机架节点间 | 100-500us | > 1ms    |
| 跨机架节点间 | 200us-1ms | > 2ms    |
| OVS upcall   | 10-100us  | > 500us  |
| vhost 处理   | 10-50us   | > 200us  |

**注意**：以上仅供参考，实际阈值应根据环境基线确定。

### 5.2.3 直方图输出解读

```
     usecs               : count     distribution
         0 -> 1          : 1523     |********                        |
         2 -> 3          : 4521     |************************        |
         4 -> 7          : 6234     |********************************|
         8 -> 15         : 2341     |************                    |
        16 -> 31         : 523      |**                              |
        32 -> 63         : 45       |                                |
        64 -> 127        : 12       |                                |
       128 -> 255        : 3        |                                |
```

**解读方法**：

| 项目             | 说明                           |
| ---------------- | ------------------------------ |
| `usecs`        | 延迟范围（微秒），对数刻度     |
| `count`        | 该范围内的包数                 |
| `distribution` | 可视化分布（星号越多占比越高） |

**分析要点**：

- **正常**：大部分 count 集中在前几行（低延迟）
- **异常**：高延迟行（如 64-127, 128-255）有明显计数
- **关注**：`distribution` 右移（星号出现在高延迟行）

### 5.2.4 Path Tracer 状态码

| 状态码                | 含义           | 建议操作                   |
| --------------------- | -------------- | -------------------------- |
| `COMPLETE`          | 四阶段都完成   | 无问题                     |
| `EXTERNAL_DROP`     | 已发出无回复   | 检查网络设备、对端         |
| `INTERNAL_DROP_REQ` | 请求未转发出去 | 检查本机路由、OVS、防火墙  |
| `INTERNAL_DROP_REP` | 回复未转发出去 | 检查本机回复路径           |
| `TIMEOUT`           | 超时未完成     | 增大 timeout-ms 或检查网络 |

### 5.2.5 丢包 Reason 含义

| Reason             | 含义           | 常见原因               |
| ------------------ | -------------- | ---------------------- |
| `NOT_SPECIFIED`  | 未指定         | 需分析调用栈           |
| `NO_SOCKET`      | 无监听 socket  | 端口未监听、服务未启动 |
| `TCP_RESET`      | TCP RST        | 连接被对端重置         |
| `TCP_ABORT`      | TCP 中止       | 连接异常中止           |
| `NETFILTER_DROP` | 防火墙丢弃     | iptables/nftables 规则 |
| `PKT_TOO_SMALL`  | 包太小         | 畸形包                 |
| `IP_CSUM_ERROR`  | IP 校验和错误  | 包损坏                 |
| `TCP_CSUM_ERROR` | TCP 校验和错误 | 包损坏                 |

---

## 5.3 场景化 FAQ

### Q5: 如何判断是本机问题还是网络问题？

**使用 icmp_path_tracer**：

```bash
sudo python icmp_path_tracer.py \
    --src-ip <本机IP> --dst-ip <对端IP> \
    --rx-iface <入口> --tx-iface <出口>
```

**判断逻辑**：

| 输出                         | 结论           | 下一步                 |
| ---------------------------- | -------------- | ---------------------- |
| 所有包 `COMPLETE`          | 路径正常       | 问题可能在应用层       |
| 部分包 `EXTERNAL_DROP`     | 网络或对端问题 | 检查网络设备、对端状态 |
| 部分包 `INTERNAL_DROP_REQ` | 本机转发问题   | 检查路由、OVS 规则     |

### Q6: 延迟高，如何快速定位瓶颈？

**步骤1**：确定网络类型

| 网络类型 | 特征                      |
| -------- | ------------------------- |
| 系统网络 | 物理机、OVS internal port |
| VM 网络  | 虚拟机（vnet/tap 接口）   |

**步骤2**：选择工具

```bash
# 系统网络
sudo python system_network_icmp_rtt.py \
    --src-ip <本机> --dst-ip <对端> \
    --phy-interface <物理口> --direction tx

# VM 网络
sudo python kernel_icmp_rtt.py \
    --src-ip <VM_IP> --dst-ip <对端> \
    --interface <物理口> --direction tx
```

**步骤3**：分析输出

- 找到延迟最大的阶段
- 该阶段对应的组件就是瓶颈

### Q7: TCP 连接丢包，如何定界？

**部署方式**：在发送端和接收端宿主机都运行

```bash
# 两端都运行
sudo python tcp_path_tracer.py \
    --src-ip <发送端IP> --dst-ip <接收端IP> \
    --rx-iface <入口> --tx-iface <出口> \
    --src-port <端口>
```

**合并分析**：

| 发送端输出           | 接收端输出           | 结论           |
| -------------------- | -------------------- | -------------- |
| 有 REQ_TX            | 无 REQ_RX            | 网络丢包       |
| 有 REQ_RX, 无 REQ_TX | -                    | 发送端内部丢包 |
| -                    | 有 REQ_RX, 无 REQ_TX | 接收端内部丢包 |

### Q8: 如何收集信息上报开发团队？

**需要收集的信息**：

```bash
# 1. 系统信息
uname -a
cat /etc/os-release

# 2. 工具输出
# 保存完整输出到文件
sudo python <工具> <参数> 2>&1 | tee output.log

# 3. 问题时间段
# 记录问题发生的时间

# 4. 测试拓扑
# 画出涉及的节点、接口、IP 关系图
```

**上报模板**：

```
问题描述：
- 现象：<简述问题>
- 时间：<首次发现时间、持续时间>
- 影响：<受影响的业务>

环境信息：
- 内核版本：<uname -r 输出>
- 系统版本：<cat /etc/os-release>
- 节点角色：<宿主机/虚拟机>

网络拓扑：
- 发送端：<IP、接口>
- 接收端：<IP、接口>
- 中间设备：<交换机、OVS 等>

工具输出：
- 见附件 output.log

复现步骤：
1. <步骤1>
2. <步骤2>
```

---

## 5.4 调试技巧

### 技巧1：逐步放宽过滤条件

```bash
# 最严格：无输出
sudo python xxx.py --src-ip 10.0.0.1 --dst-ip 10.0.0.2 --protocol tcp --port 3260

# 放宽：去掉端口
sudo python xxx.py --src-ip 10.0.0.1 --dst-ip 10.0.0.2 --protocol tcp

# 再放宽：去掉协议
sudo python xxx.py --src-ip 10.0.0.1 --dst-ip 10.0.0.2

# 最宽松：只指定接口
sudo python xxx.py --interface eth0
```

### 技巧2：用 tcpdump 验证流量

```bash
# 在运行 BPF 工具前，先用 tcpdump 确认流量
sudo tcpdump -i <接口> host <ip1> and host <ip2> -c 10 -nn

# 如果 tcpdump 能抓到包但 BPF 工具无输出，可能是过滤条件或接口名问题
```

### 技巧3：检查接口 ifindex

```bash
# BPF 工具使用 ifindex 匹配接口
cat /sys/class/net/<接口名>/ifindex

# 确保工具输出的 ifindex 与预期一致
```

### 技巧4：分阶段验证

```bash
# 先用 ICMP 工具验证基本连通性
sudo python icmp_path_tracer.py ...

# 确认 ICMP 正常后，再用 TCP/UDP 工具
sudo python tcp_path_tracer.py ...
```
