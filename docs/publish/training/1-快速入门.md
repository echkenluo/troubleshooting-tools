# 第1章 快速入门

本章帮助你在 5 分钟内掌握最常用的网络问题排查方法。

## 1.1 两阶段排查方法论

网络问题排查分为两个阶段：

```
阶段一：定界（确定问题范围）
    │
    │ 目标：确定问题发生在哪个区段
    │ 工具：path_tracer 系列、*_icmp_rtt 系列
    │ 特点：开销低，可快速执行
    │
    ↓
阶段二：详情（深入分析）
    │
    │ 前提：定界完成，问题在本机/内部
    │ 工具：*_latency_summary/details、eth_drop、kernel_drop_*
    │ 特点：提供逐包/逐阶段详细数据
```

**一线售后的核心工作在阶段一**：通过定界工具确定问题在内部还是外部，收集证据后上报开发团队。阶段二工具在开发团队指导下按需使用。

---

## 1.2 定界场景

### 场景1：丢包定界（ICMP）

**问题**：ping 对端丢包或不通，需要确定丢在哪一段。

**工具**：`icmp_path_tracer.py` — 在本机的两个接口（入口/出口）上跟踪 ICMP 包，将路径分为三段：入口→出口（内部转发）、出口→外部→出口（外部往返）、出口→入口（内部回复）。

```bash
sudo python icmp_path_tracer.py \
    --src-ip 10.0.0.1 --dst-ip 10.0.0.2 \
    --rx-iface ens4f0 --tx-iface vnet0
```

**输出解读**：

```
[14:32:15.123] ICMP id=1234 seq=1
  [0] REQ_RX  ens4f0   ts=1234567890
  [1] REQ_TX  vnet0    ts=1234567920  (+30us)
  [2] REP_RX  vnet0    ts=1234568100  (+180us)
  [3] REP_TX  ens4f0   ts=1234568130  (+30us)
  STATUS: COMPLETE

[14:32:16.125] ICMP id=1234 seq=2
  [0] REQ_RX  ens4f0   ts=1234667890
  [1] REQ_TX  vnet0    ts=1234667920  (+30us)
  STATUS: EXTERNAL_DROP (missing REP_RX after 1000ms)
```

| 状态 | 含义 | 下一步 |
|------|------|--------|
| `COMPLETE` | 包正常通过 | 无问题 |
| `INTERNAL_DROP_REQ` | 请求包在本机内部丢失 | 检查本机转发配置、OVS 规则 |
| `EXTERNAL_DROP` | 包已发出但无回复 | 检查网络、对端 |
| `INTERNAL_DROP_REP` | 回复包在本机内部丢失 | 检查本机回复路径 |

**其他协议丢包定界**：TCP/UDP 丢包使用 `tcp_path_tracer.py` / `udp_path_tracer.py`，原理相同但需要在通信双方的宿主机上分别部署，合并两端输出确定丢包段（详见第2章）。

---

### 场景2：延迟定界 — 系统网络

**问题**：系统网络（物理机、OVS internal port）延迟高，需要定位延迟在哪个阶段。

**工具**：`system_network_icmp_rtt.py` — 专用于系统网络的 ICMP RTT 分段测量，覆盖 OVS 路径。

```bash
sudo python system_network_icmp_rtt.py \
    --src-ip 10.132.114.11 --dst-ip 10.132.114.12 \
    --phy-interface ens11 --direction tx
```

**输出解读**：

```
=== System Network ICMP RTT Tracer ===
Direction: TX (local ping remote)
Filter: 10.132.114.11 -> 10.132.114.12

[14:35:22.456] seq=1 TOTAL_RTT=245us
  TX: ip_local_out -> netif_receive_skb: 45us
      netif_receive_skb -> ip_rcv: 12us
      ip_rcv -> net_dev_xmit: 28us
  RX: netif_receive_skb -> icmp_rcv: 35us
  WIRE_TIME: 125us

[14:35:23.458] seq=2 TOTAL_RTT=1523us  <<<< ABNORMAL
  TX: ip_local_out -> netif_receive_skb: 42us
      netif_receive_skb -> ip_rcv: 1105us  <<<< BOTTLENECK
      ip_rcv -> net_dev_xmit: 31us
  ...
```

**关注点**：
- `TOTAL_RTT`：总往返时间
- 各阶段时间：定位瓶颈在哪一段
- `WIRE_TIME`：网络传输时间（排除本机处理）

---

### 场景3：延迟定界 — VM 网络

**问题**：虚拟机网络延迟高，需要定位是虚拟化层、物理网络还是对端问题。

VM 网络延迟定界比系统网络复杂，因为涉及 host 侧和 VM 侧两个测量位置。

#### 方案A：Host 上部署（推荐，始终可行）

Host 上使用 `icmp_path_tracer.py` 在物理口和 vnet 口上跟踪，将路径分为 host 内部处理和外部往返两段：

```bash
# host 上运行，覆盖物理口到 vnet 口的完整路径
sudo python icmp_path_tracer.py \
    --src-ip 172.21.153.113 --dst-ip 172.21.153.114 \
    --rx-iface ens4f0 --tx-iface vnet0
```

**定界逻辑**：
- `REQ_RX → REQ_TX` 延迟大：host 内部转发（OVS/虚拟化层）瓶颈
- `REQ_TX → REP_RX` 延迟大：外部（VM 内部处理 + 网络 + 对端）瓶颈
- `REP_RX → REP_TX` 延迟大：host 内部回复路径瓶颈

#### 方案B：VM 内可部署工具

如果 VM 内可以部署 BCC 工具，用 `kernel_icmp_rtt.py` 测量 VM 内核各阶段延迟：

```bash
# VM 内运行
sudo python kernel_icmp_rtt.py \
    --src-ip 172.21.153.113 --dst-ip 172.21.153.114 \
    --interface eth0 --direction tx
```

**组合分析**：host 上 path_tracer 确定 host 内部 vs 外部，VM 内 kernel_icmp_rtt 确定 VM 内核处理 vs 网络传输。

#### 方案C：VM 内无法部署工具

当 VM 内不方便部署 BCC 工具时，可通过 ping + tcpdump 推算 VM 内延迟：

```bash
# VM 内同时执行：
# 1. ping 生成流量并记录应用感知延迟
ping -i 1 172.21.153.114

# 2. tcpdump 在 VM 网卡上抓取 ICMP request 和 reply
sudo tcpdump -i eth0 -nn icmp -w /tmp/icmp.pcap
```

**推算方法**：
- **应用感知 RTT**：ping 输出的 `time=` 值（从发送 request 到收到 reply 的完整用户态 RTT）
- **外部处理延迟**：tcpdump 中同一 seq 的 request 发出时间到 reply 到达时间的差值（网卡层面的 RTT，排除了 VM 内核协议栈处理）
- **VM 内核处理延迟**：应用感知 RTT − 外部处理延迟（粗略估算）

这些推算值与 `kernel_icmp_rtt` 的直接测量值含义类似，只是精度较低。

---

## 1.3 定界后的详细分析

定界完成后，如果问题在本机/内部，需要使用详情工具进一步分析。

### 丢包详情分析

| 工具 | 功能 | 适用场景 |
|------|------|---------|
| `eth_drop.py` | 通用丢包检测，输出丢包位置和内核调用栈 | 定位具体丢包函数 |
| `kernel_drop_stack_stats_summary_all.py` | 按调用栈聚合丢包统计 | 识别丢包热点路径 |

```bash
# 快速检测丢包位置
sudo python eth_drop.py --src-ip 10.0.0.1 --dst-ip 10.0.0.2

# 按调用栈聚合统计
sudo python kernel_drop_stack_stats_summary_all.py --interval 5
```

### 延迟详情分析

| 网络类型 | Summary 工具（低开销） | Details 工具（需过滤） |
|---------|----------------------|----------------------|
| 系统网络 | `system_network_latency_summary.py` | `system_network_latency_details.py` |
| VM 网络 | `vm_network_latency_summary.py` | `vm_network_latency_details.py` |

**分层策略**：先用 Summary 识别异常阶段和时段，再用 Details 配合过滤条件精确定位（详见第2章 2.3 节）。

---

## 1.4 快速选择指南

```
我遇到了什么问题？
    │
    ├── 丢包/不通
    │   ├── ICMP（ping）→ icmp_path_tracer.py
    │   ├── TCP → tcp_path_tracer.py（双端部署）
    │   └── UDP → udp_path_tracer.py（双端部署）
    │
    ├── 延迟高
    │   ├── 系统网络 → system_network_icmp_rtt.py
    │   └── VM 网络
    │       ├── Host 上 → icmp_path_tracer.py（始终可行）
    │       ├── VM 内可部署 → kernel_icmp_rtt.py
    │       └── VM 内不可部署 → ping + tcpdump 推算
    │
    ├── 定界完成，需深入分析
    │   ├── 丢包详情 → eth_drop.py / kernel_drop_*
    │   └── 延迟详情 → *_latency_summary.py → *_latency_details.py
    │
    └── 不确定 → 先用 icmp_path_tracer.py 看整体情况
```

---

## 1.5 下一步

- 问题无法用 ICMP 复现？→ 第2章 工具选择指南
- 需要深入了解某个工具？→ 第3章 核心工具详解
- 看不懂输出？→ 第5章 常见问题与输出解读
