#!/usr/bin/env bpftrace
#
#include <linux/skbuff.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/socket.h>
#include <linux/netdevice.h>
#include <linux/netdev_features.h>
#include <net/sock.h>
#include <uapi/linux/if_ether.h>


kprobe:iptunnel_handle_offloads
{
    $skb = (struct sk_buff *) arg0;
    $gso_type_mask = arg1;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $skb_netdev_features = $skb_net_dev->features;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    /* BUG: Loading u8 (encapsulation) garbles last value pushed onto stack. */
    $unused = (uint32) $skb->truesize;
    $encap = (uint32) $skb->encapsulation;
    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "vnet0" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("ip tunnel handle offloads probe\n");
        printf("####### gso type mask: %llx\n", $gso_type_mask);
        printf("####### skb info, skb_dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }
        printf("kstack: %s", kstack);
        printf("####### end ip tunnel handle offload  probe\n\n\n\n\n");
    }
}

kprobe:iptunnel_xmit
{
    $skb = (struct sk_buff *) arg2;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $skb_netdev_features = $skb_net_dev->features;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    /* BUG: Loading u8 (encapsulation) garbles last value pushed onto stack. */
    $unused = (uint32) $skb->truesize;
    $encap = (uint32) $skb->encapsulation;

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("ip tunnel xmit probe\n");
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }
        printf("kstack: %s", kstack);
        printf("####### end ip tunnel transmit probe\n\n\n\n\n");
    }
}

kprobe:udp_tunnel_xmit_skb
{
    $skb = (struct sk_buff *) arg2;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $skb_netdev_features = $skb_net_dev->features;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    /* BUG: Loading u8 (encapsulation) garbles last value pushed onto stack. */
    $unused = (uint32) $skb->truesize;
    $encap = (uint32) $skb->encapsulation;

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("udp tunnel xmit skb probe\n");
        printf("####### skb info, skb_dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, func);
        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }
        printf("kstack: %s", kstack);
        printf("####### end udp tunnel transmit skb probe\n\n\n\n\n");
    }
}

kprobe:skb_mac_gso_segment
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $netdev_feature = arg1;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $len = (uint32) $skb->len;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    /* BUG: Loading u8 (encapsulation) garbles last value pushed onto stack. */
    $unused = (uint32) $skb->truesize;
    $encap = (uint32) $skb->encapsulation;


    $pkt_type = $skb->pkt_type;
    $ifindex = ((struct net_device *)$skb->dev)->ifindex;

    // MAC Header (assuming Ethernet)
    $mac_header = (struct ethhdr *) $skb->data;

    // IP Header (assuming IPv4 following Ethernet)
    $ip_header_offset = $skb->data + ETH_HLEN;
    //$ip_header = (struct iphdr *) $ip_header_offset;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    // Transport Header (assuming TCP following IPv4)
    $transport_header_offset = $ip_header_offset + ($ip_header->ihl * 4);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("skb mac gso segemtation probe\n");
        printf("####### netdev_feature: %llx\n, ", $netdev_feature);
        printf("####### skb info, skb_dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);


	
        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          //if ($up_dst == 6081)
          //if ($ip_header->saddr == 0x20000064) 

          // Print the collected data
          printf("********* command: %s, func: %s\n", comm, $func);
          printf("####### header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);

          printf("kstack: %s", kstack);
          printf("end mac_gso UDP ######### \n"); 
          
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          //if ($tp_dst == 6081)
          //if ($ip_header->saddr == 0x20000064) 

          // Print the collected data
          printf("********* command: %s, func: %s\n", comm, $func);
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);

          printf("kstack: %s", kstack);
          printf("end mac_gso TCP ######### \n"); 
        }

        printf("end mac_gso ######### \n\n\n\n"); 
    }

}

kprobe:tcp_gso_segment
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $netdev_feature = arg1;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $len = (uint32) $skb->len;
    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    /* BUG: Loading u8 (encapsulation) garbles last value pushed onto stack. */
    $unused = (uint32) $skb->truesize;
    $encap = (uint32) $skb->encapsulation;

    //printf("opening: %s, %s, %s\n", str(arg0), str(arg1), str(arg2));
    $pkt_type = $skb->pkt_type;
    $ifindex = ((struct net_device *)$skb->dev)->ifindex;

    // MAC Header (assuming Ethernet)
    $mac_header = (struct ethhdr *) $skb->data;

    // IP Header (assuming IPv4 following Ethernet)
    $ip_header_offset = $skb->data + ETH_HLEN;
    //$ip_header = (struct iphdr *) $ip_header_offset;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    // Transport Header (assuming TCP following IPv4)
    $transport_header_offset = $ip_header_offset + ($ip_header->ihl * 4);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("tcp gso segemtation probe\n");

        printf("####### netdev_feature: %llx\n, ", $netdev_feature);
        printf("####### skb info, skb_dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);


        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          //if ($up_dst == 6081)
          //if ($ip_header->saddr == 0x20000064) 

          // Print the collected data
          printf("********* command: %s, func: %s\n", comm, $func);
          printf("####### header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);

          printf("kstack: %s", kstack);
          printf("end tcp_gso UDP ######### \n"); 
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          //if ($tp_dst == 6081)
          //if ($ip_header->saddr == 0x20000064) 
            
          // Print the collected data
          printf("********* command: %s, func: %s\n", comm, $func);
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);

          printf("kstack: %s", kstack);
          printf("end tcp_gso TCP ######### \n"); 
        }
	printf("end tcp gso ######### \n\n\n\n"); 
    }
}

kprobe:__skb_gso_segment
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $netdev_feature = arg1;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $len = (uint32) $skb->len;
    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    /* BUG: Loading u8 (encapsulation) garbles last value pushed onto stack. */
    $unused = (uint32) $skb->truesize;
    $encap = (uint32) $skb->encapsulation;

    //printf("opening: %s, %s, %s\n", str(arg0), str(arg1), str(arg2));
    $pkt_type = $skb->pkt_type;
    $ifindex = ((struct net_device *)$skb->dev)->ifindex;

    // MAC Header (assuming Ethernet)
    $mac_header = (struct ethhdr *) $skb->data;

    // IP Header (assuming IPv4 following Ethernet)
    $ip_header_offset = $skb->data + ETH_HLEN;
    //$ip_header = (struct iphdr *) $ip_header_offset;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    // Transport Header (assuming TCP following IPv4)
    $transport_header_offset = $ip_header_offset + ($ip_header->ihl * 4);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("skb gso segemtation probe\n");

        printf("####### netdev_feature: %llx\n, ", $netdev_feature);
        printf("####### skb info, skb_dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("********* command: %s, func: %s\n", comm, $func);
          printf("####### header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);

          printf("kstack: %s", kstack);
          printf("end skb_gso UDP ######### \n"); 
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          //if ($tp_dst == 6081)
          //if ($ip_header->saddr == 0x20000064) 
            
          // Print the collected data
          printf("********* command: %s, func: %s\n", comm, $func);
          printf("####### header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);

          printf("kstack: %s", kstack);
          printf("end skb_gso TCP ######### \n"); 
        }
        printf("end skb_gso ######### \n\n\n\n"); 
    }
}

kprobe:__udp_gso_segment
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_dev_name = $skb->dev->name;
    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $netdev_feature = arg1;
    $skb_net_dev = $skb->dev;

    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;
    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("__udp_gso_segemt probe\n");

        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }
        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end _udp_gso_segemt probe\n\n\n\n");
    }
}

kprobe:skb_segment_list
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_dev_name = $skb->dev->name;
    $skb_net_dev = $skb->dev;
    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $netdev_feature = arg1;

    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("skb_segemt_list probe\n");

        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end skb_segemt_list probe\n\n\n\n");
    }
}

kprobe:skb_segment
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_dev_name = $skb->dev->name;
    $skb_net_dev = $skb->dev;
    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $netdev_feature = arg1;

    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("skb segemt probe\n");

        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end skb segemt probe\n\n\n\n");
    }

}

//kprobe:ip_fragment
kprobe:__ip_finish_output
{

    $func = func;
    $skb = (struct sk_buff *) arg2;
    $skb_dev_name = $skb->dev->name;
    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $skb_netdev_features = $skb->dev->features;
    $skb_net_dev = $skb->dev;

    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("ip finish output probe\n");
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end ip finish output probe\n\n\n\n");
    }
}

kprobe:ip_finish_output_gso
{
    $func = func;
    $skb = (struct sk_buff *) arg2;
    $skb_dev_name = $skb->dev->name;
    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $skb_netdev_features = $skb->dev->features;
    $skb_net_dev = $skb->dev;

    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("ip finish output gso probe\n");
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
	printf("end ip finish output gso probe\n\n\n\n");
    }
}

kprobe:__icmp_send
{
    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_dev_name = $skb->dev->name;
    $skb_net_dev = $skb->dev;
    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $skb_netdev_features = $skb->dev->features;

    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("icmp send probe\n");

        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end icmp send probe\n\n\n\n");
    }
}

kprobe:ip_fragment.constprop.0
{
    $func = func;
    $skb = (struct sk_buff *) arg2;
    $skb_dev_name = $skb->dev->name;
    $skb_net_dev = $skb->dev;
    $skb_netdev_features = $skb->dev->features;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;
    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("ip fragment probe\n");

        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end ip fragment probe\n\n\n\n");
    }
}

kprobe:mlx5e_xmit,
kprobe:internal_dev_xmit
{

    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_dev_name = $skb->dev->name;
    $skb_net_dev = $skb->dev;
    $netdev_feature = arg1;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;

    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);

    if ($skb_dev_name == "em3") {
        printf("mlx5e transmit probe\n");
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end mlx5e port transmit probe\n\n\n\n");
    }

    if ($skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") {
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end internal port transmit probe\n\n\n\n");
    }
}

kprobe:validate_xmit_skb
{

    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $skb_netdev_features = $skb_net_dev->features;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;

    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);
    $ether_protocol = (($mac_header->h_proto & 0xff00) >> 8) | (($mac_header->h_proto & 0x00ff) << 8) ;
    if ($ether_protocol != 0x0800) {
	//printf("ether protocol: %llx\n", $ether_protocol);
	return
    }
    //$addr = pton(AF_INET, "0.0.0.0");
    //if (strcmp(str("0.0.0.0"), str($addr), 4) == 0) {
    //    printf("src addr 0.0.0.0\n")
    //    return
    //}
    if ($ip_header->protocol == IPPROTO_UDP)
    {
      //$udp_header = (struct udphdr *) $transport_header_offset;
      $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
      $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
      $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);
      if ($up_src == 67 || $up_src == 68) {
          return
      }
    }

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("validate transmit skb probe\n");
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);

        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end validate transmit skb probe\n\n\n\n\n");
    }
}


kprobe:netif_skb_features
{

    $func = func;
    $skb = (struct sk_buff *) arg0;
    $skb_net_dev = $skb->dev;
    $skb_dev_name = $skb->dev->name;
    $skb_netdev_features = $skb_net_dev->features;

    $shinfo = (struct skb_shared_info *) ($skb->head + $skb->end);
    $gso_size = (uint32) $shinfo->gso_size;
    $gso_segs = (uint32) $shinfo->gso_segs;
    $gso_type = (uint32) $shinfo->gso_type;
    $nr_frags = (uint32) $shinfo->nr_frags;

    $nh = (uint32) $skb->network_header;
    $th = (uint32) $skb->transport_header;
    $inh = (uint32) $skb->inner_network_header;
    $ith = (uint32) $skb->inner_transport_header;
    $inner_protocol = (($skb->inner_protocol & 0xff00) >> 8) | (($skb->inner_protocol & 0x00ff) << 8);
    $inner_protocol_type = $skb->inner_protocol_type;
    $encap = (uint32) $skb->encapsulation;
    $len = (uint32) $skb->len;

    $mac_header = (struct ethhdr *) $skb->data;
    $ip_header = (struct iphdr *)($skb->head + $skb->network_header);
    $sip = ntop(AF_INET, $ip_header->saddr);
    $dip = ntop(AF_INET, $ip_header->daddr);
 
    $ether_protocol = (($mac_header->h_proto & 0xff00) >> 8) | (($mac_header->h_proto & 0x00ff) << 8) ;
    if ($ether_protocol != 0x0800) {
	//printf("ether protocol: %llx\n", $ether_protocol);
	return
    }
    if ($ip_header->protocol == IPPROTO_UDP)
    {
      //$udp_header = (struct udphdr *) $transport_header_offset;
      $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
      $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
      $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);
      if ($up_src == 67 || $up_src == 68) {
          return
      }
    }

    if ($skb_dev_name == "em3" || $skb_dev_name == "port-vpc" || $skb_dev_name == "tep" || $skb_dev_name == "genev_sys_6081" || $skb_dev_name == "vnet1" || $skb_dev_name == "vnet0" || $skb_dev_name == "vpcbr" || $skb_dev_name == "ovsbr-0yjfwa39i") 
    {
        printf("netif skb features probe\n");
        printf("####### skb info, dev_name: %-4s\t, skb dev features: %llx\t, skb_len: %u,\t network_header: %u,\t transport_header: %u,\t encap: %-3u,\t inner_network_header: %u,\t inner_transport_header: %u,\t | gso_size: %-4u,\t gso_segs: %-4u,\t gso_type: 0x%02x,\t nr_frags: %u\t, func: %s\n", $skb_dev_name, $skb_net_dev->features, $len, $nh, $th, $encap, $inh, $ith, $gso_size, $gso_segs, $gso_type, $nr_frags, $func);
        $netdev_features = $skb_net_dev->features;
        $netdev_hw_features = $skb_net_dev->hw_features;
        $netdev_wanted_features = $skb_net_dev->wanted_features;
        $netdev_hwenc_features = $skb_net_dev->hw_enc_features;
        $netdev_gso_partial_features = $skb_net_dev->gso_partial_features;
        printf("####### skb_dev hardware features, netdev_features: %llx\t hw_features: %llx\t wanted_features: %llx\t hwenc_features: %llx\t gso_partial_features: %llx\n", $netdev_features, $netdev_hw_features, $netdev_wanted_features, $netdev_hwenc_features, $netdev_gso_partial_features);
        if ($ip_header->protocol == IPPROTO_UDP)
        {
          //$udp_header = (struct udphdr *) $transport_header_offset;
          $udp_header = (struct udphdr *)($skb->head + $skb->transport_header);
          $up_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $up_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### udp header info: %s:%d => %s:%d\n", $sip, $up_src, $dip, $up_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        if ($ip_header->protocol == IPPROTO_TCP)
        {
          $tcp_header = (struct tcphdr *)($skb->head + $skb->transport_header);
          $tp_src = (($udp_header->source & 0xff00) >> 8) | (($udp_header->source & 0x00ff) << 8);
          $tp_dst = (($udp_header->dest & 0xff00) >> 8) | (($udp_header->dest & 0x00ff) << 8);

          // Print the collected data
          printf("####### tcp header info data: %s:%d => %s:%d\n", $sip, $tp_src, $dip, $tp_dst);
          printf("####### MAC src: %02x:%02x:%02x:%02x:%02x:%02x, MAC dst: %02x:%02x:%02x:%02x:%02x:%02x\n",
             $mac_header->h_source[0], $mac_header->h_source[1], $mac_header->h_source[2],
             $mac_header->h_source[3], $mac_header->h_source[4], $mac_header->h_source[5],
             $mac_header->h_dest[0], $mac_header->h_dest[1], $mac_header->h_dest[2],
             $mac_header->h_dest[3], $mac_header->h_dest[4], $mac_header->h_dest[5]);
        }

        printf("netdev name: %s\n, kstack: %s", $skb_dev_name, kstack);
        printf("end netif skb feature probe\n\n\n\n\n");
    }
}
